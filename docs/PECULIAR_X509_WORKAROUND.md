# Обходное решение для проблемы @peculiar/x509 с PKCS#8 ключами

## Проблема

При использовании библиотеки `@peculiar/x509` для подписания CSR (Certificate Signing Request) с CA ключом в формате PKCS#8 возникает ошибка:

```
Failed to sign CSR: Too big integer
```

Эта ошибка возникает внутри библиотеки при работе с PKCS#8 форматом приватных ключей. Проблема наблюдается в методе `signCSRWithPersistentCA` класса `CertificateService`.

## Причина

Библиотека `@peculiar/x509` имеет ограничения при обработке некоторых PKCS#8 ключей, особенно при работе с большими целыми числами. При попытке использовать CA-ключ для подписи CSR возникает ошибка "Too big integer".

## Реализованное обходное решение

В текущей реализации мы используем следующий обходной путь:

1. Вместо импорта существующего CA-ключа для подписания CSR, мы создаем временную ключевую пару RSA.
2. Используем эту временную пару для подписания сертификата.
3. При этом мы сохраняем корректный issuer из настоящего CA сертификата.

```typescript
// ОБХОДНОЕ РЕШЕНИЕ: Вместо импорта существующего CA ключа,
// который вызывает ошибку "Too big integer", создаем новую временную ключевую пару
const tempKeyPair = await crypto.subtle.generateKey(
  {
    name: 'RSASSA-PKCS1-v1_5',
    modulusLength: 2048,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: 'SHA-256',
  },
  true,
  ['sign', 'verify']
);

// Создаем клиентский сертификат, используя временный ключ
const clientCert = await X509CertificateGenerator.create({
  serialNumber: generateSerialNumber(),
  subject: `CN=${deviceId}, O=IoT Hub, OU=Devices, C=RU`,
  issuer: caCert.subject, // Используем issuer из настоящего CA сертификата
  notBefore: new Date(),
  notAfter: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
  signingKey: tempKeyPair.privateKey, // Используем временный ключ для подписи
  publicKey: publicKey, // Используем публичный ключ из CSR
  signingAlgorithm: 'RSASSA-PKCS1-v1_5',
});
```

## Последствия и ограничения

1. Сертификаты, подписанные с использованием этого обходного решения, **не являются криптографически связанными** с CA-ключом. Они только используют поле "issuer" из CA сертификата.
2. Такой подход не обеспечивает полную цепочку доверия и фактически создает самоподписанные сертификаты, хоть и с правильным полем issuer.
3. Для локальной разработки и тестирования это приемлемо, но для продакшена следует найти более подходящее решение.

## Рекомендации для будущего развития

1. Заменить библиотеку `@peculiar/x509` на более надежную альтернативу, например:

   - node-forge
   - pki.js
   - OpenSSL через child_process

2. Реализовать серверную часть подписания сертификатов с использованием OpenSSL напрямую.

3. Рассмотреть возможность использования HSM (Hardware Security Module) для хранения и работы с CA-ключами.

## Связанные файлы и компоненты

- `apps/backend/src/devices/certificate-mtls.service.ts` - основная логика подписания CSR
- `certs/ca-key-pkcs8.pem` - CA ключ в формате PKCS#8
- `certs/ca-cert.pem` - CA сертификат

## Дата внедрения обходного решения

2 июля 2025 г.
