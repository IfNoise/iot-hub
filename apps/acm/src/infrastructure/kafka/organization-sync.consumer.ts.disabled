import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { Consumer, Kafka } from 'kafkajs';
import {
  type OrganizationCreatedEvent,
  type OrganizationUpdatedEvent,
  type OrganizationDeletedEvent,
  KafkaTopics,
  ConsumerGroups,
} from '@iot-hub/contracts-kafka';
import { ConfigService } from '../../config/config.service.js';
import { OrganizationsService } from '../../acm/organizations.service.js';

/**
 * Consumer для синхронизации организаций из Keycloak
 * Слушает события создания/обновления/удаления организаций
 */
@Injectable()
export class OrganizationSyncConsumer implements OnModuleInit, OnModuleDestroy {
  private kafka: Kafka;
  private consumer: Consumer;

  constructor(
    @InjectPinoLogger(OrganizationSyncConsumer.name)
    private readonly logger: PinoLogger,
    private readonly configService: ConfigService,
    private readonly organizationsService: OrganizationsService
  ) {
    const kafkaConfig = this.configService.kafka.getKafkaOptions();
    this.kafka = new Kafka(kafkaConfig);
    this.consumer = this.kafka.consumer({
      groupId: ConsumerGroups.ACM_ORGANIZATION_SYNC,
    });
  }

  async onModuleInit() {
    try {
      await this.consumer.connect();
      
      // Подписываемся на топики организаций
      await this.consumer.subscribe({
        topics: [
          KafkaTopics.ORGANIZATION_CREATED,
          KafkaTopics.ORGANIZATION_UPDATED,
          KafkaTopics.ORGANIZATION_DELETED,
        ],
        fromBeginning: false,
      });

      await this.consumer.run({
        eachMessage: async ({ topic, partition, message }) => {
          try {
            if (!message.value) {
              this.logger.warn('Empty message received', { topic, partition });
              return;
            }

            const event = JSON.parse(message.value.toString());
            
            this.logger.info('Processing organization event', {
              topic,
              eventId: event.eventId,
              organizationId: event.payload?.organizationId,
            });

            switch (topic) {
              case KafkaTopics.ORGANIZATION_CREATED:
                await this.handleOrganizationCreated(event as OrganizationCreatedEvent);
                break;
              case KafkaTopics.ORGANIZATION_UPDATED:
                await this.handleOrganizationUpdated(event as OrganizationUpdatedEvent);
                break;
              case KafkaTopics.ORGANIZATION_DELETED:
                await this.handleOrganizationDeleted(event as OrganizationDeletedEvent);
                break;
              default:
                this.logger.warn('Unknown topic', { topic });
            }
          } catch (error) {
            this.logger.error('Error processing organization event', {
              error: error instanceof Error ? error.message : error,
              topic,
              partition,
              offset: message.offset,
            });
            // В production здесь может быть логика повторной обработки или DLQ
          }
        },
      });

      this.logger.info('Organization sync consumer started successfully');
    } catch (error) {
      this.logger.error('Failed to start organization sync consumer', {
        error: error instanceof Error ? error.message : error,
      });
      throw error;
    }
  }

  async onModuleDestroy() {
    try {
      await this.consumer.disconnect();
      this.logger.info('Organization sync consumer disconnected');
    } catch (error) {
      this.logger.error('Error disconnecting organization sync consumer', {
        error: error instanceof Error ? error.message : error,
      });
    }
  }

  /**
   * Обработка события создания организации
   */
  private async handleOrganizationCreated(event: OrganizationCreatedEvent) {
    try {
      const { organizationId, name, description, settings } = event.payload;

      // Проверяем, не существует ли уже такая организация
      const existingOrg = await this.organizationsService.findByKeycloakId(organizationId);
      if (existingOrg) {
        this.logger.info('Organization already exists, skipping creation', {
          organizationId,
          existingId: existingOrg.id,
        });
        return;
      }

      // Создаем организацию в базе данных
      await this.organizationsService.syncFromKeycloak({
        keycloakId: organizationId,
        name,
        description: description || null,
        settings: settings || {},
        isActive: true,
      });

      this.logger.info('Organization created successfully', {
        organizationId,
        name,
      });
    } catch (error) {
      this.logger.error('Failed to handle organization created event', {
        error: error instanceof Error ? error.message : error,
        eventId: event.eventId,
        organizationId: event.payload.organizationId,
      });
      throw error;
    }
  }

  /**
   * Обработка события обновления организации
   */
  private async handleOrganizationUpdated(event: OrganizationUpdatedEvent) {
    try {
      const { organizationId, name, description, settings } = event.payload;

      // Обновляем организацию в базе данных
      await this.organizationsService.updateFromKeycloak(organizationId, {
        name,
        description: description || null,
        settings: settings || {},
      });

      this.logger.info('Organization updated successfully', {
        organizationId,
        name,
      });
    } catch (error) {
      this.logger.error('Failed to handle organization updated event', {
        error: error instanceof Error ? error.message : error,
        eventId: event.eventId,
        organizationId: event.payload.organizationId,
      });
      throw error;
    }
  }

  /**
   * Обработка события удаления организации
   */
  private async handleOrganizationDeleted(event: OrganizationDeletedEvent) {
    try {
      const { organizationId } = event.payload;

      // Помечаем организацию как удаленную (soft delete)
      await this.organizationsService.softDeleteByKeycloakId(organizationId);

      this.logger.info('Organization soft deleted successfully', {
        organizationId,
      });
    } catch (error) {
      this.logger.error('Failed to handle organization deleted event', {
        error: error instanceof Error ? error.message : error,
        eventId: event.eventId,
        organizationId: event.payload.organizationId,
      });
      throw error;
    }
  }
}
