import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { Consumer, Kafka, KafkaConfig } from 'kafkajs';
import { KafkaTopics, ConsumerGroups } from '@iot-hub/contracts-kafka';
import { ConfigService } from '../../config/config.service.js';
import { UserService } from '../../user/user.service.js';
import { OrganizationsService } from '../../acm/organizations.service.js';
import { KeycloakIntegrationService } from '../keycloak/keycloak-integration.service.js';

export interface KeycloakUserEvent {
  '@class': string;
  id: string | null;
  time: number;
  type: 'REGISTER' | 'LOGIN' | 'LOGOUT' | 'UPDATE_PROFILE' | 'DELETE_ACCOUNT';
  realmId: string;
  realmName: string | null;
  clientId: string;
  userId: string;
  sessionId: string | null;
  ipAddress: string;
  error: string | null;
  details: {
    username?: string;
    email?: string;
    first_name?: string;
    last_name?: string;
    organizationId?: string;
    auth_method?: string;
    auth_type?: string;
    register_method?: string;
    redirect_uri?: string;
    code_id?: string;
    [key: string]: unknown;
  };
}

export interface KeycloakAdminEvent {
  '@class': string;
  id: string | null;
  time: number;
  realmId: string;
  realmName: string | null;
  authDetails: {
    realmId: string;
    realmName: string;
    clientId: string;
    userId: string;
    ipAddress: string;
  };
  resourceType: 'USER' | 'GROUP' | 'ROLE' | 'CLIENT' | 'REALM';
  operationType: 'CREATE' | 'UPDATE' | 'DELETE' | 'ACTION';
  resourcePath: string;
  representation: string | null;
  error: string | null;
  details: Record<string, unknown> | null;
  resourceTypeAsString: string;
}

@Injectable()
export class KeycloakEventConsumer implements OnModuleInit, OnModuleDestroy {
  private consumer!: Consumer;
  private kafka!: Kafka;

  constructor(
    private readonly configService: ConfigService,
    @Inject(forwardRef(() => UserService))
    private readonly userService: UserService,
    @Inject(forwardRef(() => OrganizationsService))
    private readonly organizationsService: OrganizationsService,
    private readonly keycloakIntegrationService: KeycloakIntegrationService,
    @InjectPinoLogger(KeycloakEventConsumer.name)
    private readonly logger: PinoLogger
  ) {}

  async onModuleInit() {
    if (!this.configService.kafka.isEnabled()) {
      this.logger.info('Kafka is disabled, skipping consumer initialization');
      return;
    }

    try {
      const kafkaOptions = this.configService.kafka.getKafkaOptions();

      // Адаптируем конфигурацию для совместимости с KafkaConfig
      const adaptedKafkaConfig: KafkaConfig = {
        clientId: kafkaOptions.clientId,
        brokers: kafkaOptions.brokers,
        ssl: kafkaOptions.ssl,
        connectionTimeout: kafkaOptions.connectionTimeout,
        requestTimeout: kafkaOptions.requestTimeout,
        retry: kafkaOptions.retry,
      };

      // Добавляем SASL если он настроен
      if (
        kafkaOptions.sasl &&
        kafkaOptions.sasl.username &&
        kafkaOptions.sasl.password
      ) {
        const mechanism = kafkaOptions.sasl.mechanism;
        if (mechanism === 'plain') {
          adaptedKafkaConfig.sasl = {
            mechanism: 'plain',
            username: kafkaOptions.sasl.username,
            password: kafkaOptions.sasl.password,
          };
        } else if (mechanism === 'scram-sha-256') {
          adaptedKafkaConfig.sasl = {
            mechanism: 'scram-sha-256',
            username: kafkaOptions.sasl.username,
            password: kafkaOptions.sasl.password,
          };
        } else if (mechanism === 'scram-sha-512') {
          adaptedKafkaConfig.sasl = {
            mechanism: 'scram-sha-512',
            username: kafkaOptions.sasl.username,
            password: kafkaOptions.sasl.password,
          };
        }
      }

      this.kafka = new Kafka(adaptedKafkaConfig);

      this.consumer = this.kafka.consumer({
        groupId: ConsumerGroups.AuthService,
        sessionTimeout: 30000,
        heartbeatInterval: 3000,
      });

      await this.consumer.connect();
      this.logger.info('Kafka consumer connected');

      // Получаем список доступных топиков для проверки их существования
      const admin = this.kafka.admin();
      await admin.connect();

      const availableTopics = await admin.listTopics();
      await admin.disconnect();

      // Получаем конфигурацию Keycloak топиков
      const keycloakTopics = this.configService.kafka.getKeycloakTopics();

      // Проверяем, какие топики доступны для подписки
      const topicsToSubscribe = [
        keycloakTopics.userEvents,
        keycloakTopics.adminEvents,
        KafkaTopics.UserEvents,
        KafkaTopics.OrganizationEvents,
      ].filter((topic) => {
        const exists = availableTopics.includes(topic);
        if (!exists) {
          this.logger.warn(
            `Topic ${topic} does not exist, skipping subscription`
          );
        }
        return exists;
      });

      if (topicsToSubscribe.length === 0) {
        this.logger.warn(
          'No topics available for subscription, consumer will not process any messages'
        );
        return;
      }

      // Подписываемся только на существующие топики
      await this.consumer.subscribe({
        topics: topicsToSubscribe,
        fromBeginning: false,
      });

      this.logger.info(`Subscribed to topics: ${topicsToSubscribe.join(', ')}`);

      await this.consumer.run({
        eachMessage: async ({ topic, message }) => {
          try {
            if (!message.value) {
              this.logger.warn('Received empty message');
              return;
            }

            const eventData = JSON.parse(message.value.toString());
            this.logger.debug(
              `Processing event from topic ${topic}:`,
              eventData
            );

            // Получаем конфигурацию Keycloak топиков
            const keycloakTopics = this.configService.kafka.getKeycloakTopics();

            switch (topic) {
              case keycloakTopics.userEvents:
                await this.handleKeycloakUserEvent(
                  eventData as KeycloakUserEvent
                );
                break;
              case keycloakTopics.adminEvents:
                await this.handleKeycloakAdminEvent(
                  eventData as KeycloakAdminEvent
                );
                break;
              case KafkaTopics.UserEvents:
                await this.handleUserEvent(eventData);
                break;
              case KafkaTopics.OrganizationEvents:
                await this.handleOrganizationEvent(eventData);
                break;
              default:
                this.logger.warn(`Unknown topic: ${topic}`);
            }
          } catch (error) {
            this.logger.error(`Error processing message from ${topic}:`, error);
            // Не выбрасываем ошибку, чтобы consumer продолжал работать
          }
        },
      });

      this.logger.info(
        'Kafka consumer is running and listening for messages...'
      );
    } catch (error) {
      this.logger.error('Failed to initialize Kafka consumer:', error);
    }
  }

  async onModuleDestroy() {
    if (this.consumer) {
      try {
        await this.consumer.disconnect();
        this.logger.info('Kafka consumer disconnected');
      } catch (error) {
        this.logger.error('Error disconnecting Kafka consumer:', error);
      }
    }
  }

  private async handleKeycloakUserEvent(
    event: KeycloakUserEvent
  ): Promise<void> {
    this.logger.info(
      `Handling Keycloak user event: ${event.type} for user ${event.userId}`
    );

    try {
      switch (event.type) {
        case 'REGISTER':
          this.logger.info(`Processing user registration for ${event.userId}`);
          try {
            // 1. Создаем пользователя из данных REGISTER события
            const userData = this.extractUserDataFromRegisterEvent(event);

            if (!userData) {
              this.logger.error(
                `Failed to extract user data from REGISTER event for ${event.userId}`
              );
              throw new Error(
                `Could not extract user data from REGISTER event`
              );
            }

            // 2. Создаем пользователя в локальной базе данных
            const syncedUser = await this.userService.createUserFromEventData(
              userData
            );

            if (!syncedUser) {
              this.logger.error(
                `Failed to create user ${event.userId} from REGISTER event data`
              );
              throw new Error(
                `User ${event.userId} could not be created from event data`
              );
            }

            this.logger.info(
              `User ${event.userId} successfully created from REGISTER event`
            );

            // 3. Если есть organizationId, создаем/синхронизируем организацию
            if (event.details.organizationId) {
              // Получаем внутренний ID пользователя из базы данных
              const internalUserId =
                await this.userService.getInternalIdByUserId(syncedUser.userId);
              if (!internalUserId) {
                this.logger.error(
                  `Internal ID for user ${syncedUser.userId} not found in database after creation`
                );
                throw new Error(
                  `Internal ID for user ${syncedUser.userId} not found`
                );
              }

              await this.syncOrganizationFromRegisterEvent(
                event.details.organizationId,
                internalUserId // Используем внутренний ID из базы данных
              );
            }
          } catch (syncError) {
            this.logger.error(
              `Failed to sync user ${event.userId} during REGISTER event:`,
              syncError
            );
            // Выбрасываем ошибку, так как без пользователя нельзя создать организацию
            throw syncError;
          }
          break;
        case 'UPDATE_PROFILE':
          this.logger.info(`Processing profile update for ${event.userId}`);
          try {
            // 1. Синхронизируем обновления пользователя
            await this.userService.syncFromKeycloak(event.userId);
          } catch (syncError) {
            this.logger.error(
              `Failed to sync user ${event.userId} during UPDATE_PROFILE event:`,
              syncError
            );
            // Не выбрасываем ошибку, чтобы не прерывать обработку других сообщений
          }
          break;
        case 'DELETE_ACCOUNT':
          this.logger.info(`Processing account deletion for ${event.userId}`);
          // В ACM мы не удаляем пользователей полностью, а помечаем как деактивированных
          this.logger.info(
            `User ${event.userId} deleted in Keycloak, marking as inactive in ACM`
          );
          break;
        case 'LOGIN':
          // Возможно, в будущем добавим события логина
          this.logger.debug(`User login event for ${event.userId}`);
          break;
        case 'LOGOUT':
          // Возможно, в будущем добавим события логаута
          this.logger.debug(`User logout event for ${event.userId}`);
          break;
        default:
          this.logger.warn(`Unhandled user event type: ${event.type}`);
      }
    } catch (error) {
      this.logger.error(`Error handling user event ${event.type}:`, error);
      throw error;
    }
  }

  private async handleKeycloakAdminEvent(
    event: KeycloakAdminEvent
  ): Promise<void> {
    try {
      this.logger.debug(
        `Processing Keycloak admin event: ${event.operationType} ${event.resourceType}`
      );

      // Обрабатываем только события создания/обновления пользователей
      if (event.resourceType === 'USER' && event.operationType === 'CREATE') {
        // Извлекаем userId из resourcePath
        const userIdMatch = event.resourcePath.match(/users\/([^/]+)/);
        if (userIdMatch) {
          const userId = userIdMatch[1];
          await this.userService.syncFromKeycloak(userId);
          this.logger.info(`User created via admin: ${userId}`);
        }
      }
    } catch (error) {
      this.logger.error('Error handling Keycloak admin event:', error);
    }
  }

  private async handleUserEvent(eventData: unknown): Promise<void> {
    try {
      const event = eventData as {
        eventType: string;
        payload: { userId: string };
      };
      this.logger.debug(`Processing user event: ${event.eventType}`);

      if (event.eventType === 'user.created') {
        await this.userService.syncFromKeycloak(event.payload.userId);
      } else if (event.eventType === 'user.updated') {
        await this.userService.syncFromKeycloak(event.payload.userId);
      }
    } catch (error) {
      this.logger.error('Error handling user event:', error);
    }
  }

  private async handleOrganizationEvent(eventData: unknown): Promise<void> {
    try {
      const event = eventData as {
        eventType: string;
        payload: { organizationId: string };
      };
      this.logger.debug(`Processing organization event: ${event.eventType}`);

      if (event.eventType === 'organization.created') {
        await this.organizationsService.syncOrganizationFromRegisterEvent({
          keycloakId: event.payload.organizationId,
          name: 'Unknown Organization', // Будет обновлено из Keycloak
          slug: 'organization-' + event.payload.organizationId,
          plan: 'basic',
          maxUsers: 10,
          maxDevices: 100,
          ownerId: 'system',
          status: 'active',
        });
      }
    } catch (error) {
      this.logger.error('Error handling organization event:', error);
    }
  }

  private async syncOrganizationFromRegisterEvent(
    organizationId: string,
    ownerId: string // Это ID пользователя в нашей базе данных (users.id), а не Keycloak ID
  ): Promise<void> {
    try {
      // Получаем данные организации из Keycloak
      const keycloakOrganization =
        await this.keycloakIntegrationService.getOrganizationById(
          organizationId
        );

      if (!keycloakOrganization) {
        this.logger.warn(
          `Organization not found in Keycloak: ${organizationId}`
        );
        return;
      }

      // Создаем/синхронизируем организацию
      const createdOrganization =
        await this.organizationsService.syncFromKeycloakEvent({
          organizationId,
          name: keycloakOrganization.name,
          displayName: keycloakOrganization.name,
          domain: undefined,
          ownerId: ownerId, // Внутренний ID пользователя из нашей базы данных
          createdAt: new Date().toISOString(),
          isEnabled: true,
          keycloakId: organizationId,
        });

      this.logger.info(
        `Synced organization from Keycloak: ${organizationId} for owner: ${ownerId}`
      );

      // Обновляем пользователя как владельца организации
      if (createdOrganization) {
        // Получаем пользователя по внутреннему ID
        const ownerUser = await this.userService.findByInternalId(ownerId);

        if (ownerUser) {
          await this.userService.updateAsOrganizationOwner(
            ownerUser.userId, // Keycloak ID для поиска в методе update
            createdOrganization.id.toString() // ID созданной организации
          );

          this.logger.info(
            `Updated user ${ownerUser.userId} as owner of organization ${createdOrganization.id}`
          );
        } else {
          this.logger.warn(
            `Owner user not found by internal ID ${ownerId} after organization creation`
          );
        }
      }
    } catch (error) {
      this.logger.error(`Error syncing organization ${organizationId}:`, error);
      throw error;
    }
  }

  private extractUserDataFromRegisterEvent(event: KeycloakUserEvent) {
    try {
      const details = event.details || {};

      // Извлекаем данные пользователя из события
      const userData = {
        userId: event.userId,
        email: details.email,
        username: details.username,
        firstName: details.first_name,
        lastName: details.last_name,
        organizationId: details.organizationId,
      };

      // Проверяем обязательные поля
      if (!userData.email || !userData.username) {
        this.logger.warn(
          `Missing required user data in REGISTER event for ${event.userId}: email=${userData.email}, username=${userData.username}`
        );
        return null;
      }

      this.logger.debug(
        `Extracted user data from REGISTER event: ${JSON.stringify(userData)}`
      );

      return userData;
    } catch (error) {
      this.logger.error(
        `Error extracting user data from REGISTER event: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      return null;
    }
  }
}
